---
abbrlink: ''
categories:
- - 算法
date: '2024-11-16T10:28:33.253511+08:00'
tags:
- 前缀和
title: 动态规划 —— 前缀和
updated: '2024-11-16T10:28:38.208+08:00'
---
# 动态规划 —— 前缀和

## 前缀和的引入

在数据处理的过程中，我们有时会遇到这样一种情况——求区间和。
按照我们正常的思维，应该是直接从区间的起始位置遍历到区间的终止位置。让我们算算时间复杂度，嗯~ $O(n)$，看上去非常完美。
那么不出意外就要出意外啦。
请思考一下，如果对**同一个**数组，我有 $m$ 次询问，每次的长度为k，那么此时的时间复杂度又是多少呢？
大致应该为$O(m*k)$ 。当 $m$ 和 $k$ 的基数都很小的时候，我们暴力的去遍历当然没有问题，但是当 $m$ 和 $k$ 都是**很大**的值的时候，这样的时间复杂度就显得不太乐观了。
如此大的时间复杂度我们又应该怎么去优化呢？
莫慌，还是有解决办法滴~。那么就请出我们今天的主角——前缀和 !

## 前缀和的公式推导

前缀和，顾名思义，就是求数组中前 i 个数字的和。
这么解释有些抽象，我们举个例子叭。

我们用 $a[N]$ 数组表示我们的初始数组，用 $s[i]$ 表示前 $i$ 个数字的和。
即：

```cpp
s[1] = a[1]
s[2] = a[1] + a[2]
s[3] = a[1] + a[2] + a[3]
s[4] = a[1] + a[2] + a[3] + a[4]
```

好啦，我们来找找规律叭
从上面的例子中我们不难发现

```
s[2] = s[1] + a[2]
s[3] = s[2] + a[3]
s[4] = s[3] + a[4]
```

那么我们就可以得出一个公式
对于 $i$ 位置上的数字,其前缀和就应该为

```
s[i] = s[i - 1] + a[i]
```

好啦，我们现在就把前缀和的公式推导出来啦。
那么，我们求出了前缀和又应该怎么去求区间和呢？

## 前缀和的应用

我们让我们回到这里

```
s[1] = a[1]
s[2] = a[1] + a[2]
s[3] = a[1] + a[2] + a[3]
s[4] = a[1] + a[2] + a[3] + a[4]
```

那么假设我们要求从 2 到 4 的区间和，即$ a[2] + a[3] + a[4] $那么观察一下上边的式子，我们很容易就会发现,$ s[4] - s[1] $的结果正好为$ a[2] + a[3] + a[4] $,这是巧合吗？当然不是，不信你可以自己列式，去算一算其他的区间，也一样符合这个公式。即要求 从 $a$ 到 $b$ 的区间和  $（ a<b ）$，则公式为

```
sum = a[b] - a[a - 1]
```

这就是我们前缀和的公式啦！
那么光学不练假把式，我们去做做题吧
[前缀和、差分与离散化 ](https://www.luogu.com.cn/training/200#problems)

